import { encodeBase64, encodeHex } from '$encoding';

/**
 * Output encoding options for the secret generator
 */
export type SecretEncoding = 'hex' | 'base64' | 'raw' | 'alphanumeric';

/**
 * Options for secret generation
 */
export interface SecretGeneratorOptions {
  /**
   * Length of the secret in bytes
   */
  byteLength: number;

  /**
   * Optional prefix to add to the secret
   * @default ''
   */
  prefix?: string;

  /**
   * Interval at which to insert hyphens
   * @default 0 (no hyphens)
   */
  hyphenInterval?: number;

  /**
   * Encoding to use for the output
   * @default 'hex'
   */
  encoding?: SecretEncoding;

  /**
   * Whether to force lowercase output (for string outputs only)
   * @default false
   */
  lowercase?: boolean;
}

/**
 * Generates a cryptographically secure random secret suitable for encryption algorithms.
 *
 * @param {number | SecretGeneratorOptions} byteLengthOrOptions - The length of the secret in bytes or an options object
 * @param {SecretEncoding} encoding - The encoding to use for the output ('hex', 'base64', 'alphanumeric', or 'raw').
 *                                   Defaults to 'hex'.
 * @param {string} prefix - An optional prefix to be added to the secret. Only applied for string outputs.
 *                         Defaults to an empty string.
 * @param {number} hyphenInterval - The interval at which hyphens should be inserted. Defaults to 0 (no hyphens).
 * @returns {string | Uint8Array} The generated secret in the specified encoding (string) or as a Uint8Array if raw.
 *
 * @example
 * // Generate a 32-byte (256-bit) secret in hex format
 * const secret = secretGenerator(32);
 * console.log(secret); // Logs a 64-character hex string (32 bytes)
 *
 * @example
 * // Generate a 16-byte (128-bit) secret in base64 format
 * const secret = secretGenerator(16, 'base64');
 * console.log(secret); // Logs a base64-encoded string
 *
 * @example
 * // Generate a 24-byte (192-bit) secret as raw bytes
 * const secret = secretGenerator(24, 'raw');
 * console.log(secret); // Logs a Uint8Array of 24 bytes
 *
 * @example
 * // Generate a secret with a prefix
 * const secret = secretGenerator(32, 'hex', 'key:');
 * console.log(secret); // Logs a prefixed hex string
 *
 * @example
 * // Generate a secret with hyphens inserted at intervals
 * const secret = secretGenerator(16, 'hex', '', 4);
 * console.log(secret); // Logs a hex string with hyphens every 4 characters
 *
 * @example
 * // Generate a secret using options object
 * const secret = secretGenerator({
 *   byteLength: 16,
 *   encoding: 'alphanumeric',
 *   prefix: 'key-',
 *   hyphenInterval: 4,
 *   lowercase: true
 * });
 * console.log(secret); // Logs a formatted alphanumeric key
 */
export const secretGenerator = (
  byteLengthOrOptions: number | SecretGeneratorOptions,
  encoding: SecretEncoding = 'hex',
  prefix = '',
  hyphenInterval = 0,
): string | Uint8Array => {
  // Parse options
  let byteLength: number;
  let finalEncoding: SecretEncoding;
  let finalPrefix: string;
  let finalHyphenInterval: number;
  let lowercase = false;

  if (typeof byteLengthOrOptions === 'object') {
    byteLength = byteLengthOrOptions.byteLength;
    finalEncoding = byteLengthOrOptions.encoding ?? 'hex';
    finalPrefix = byteLengthOrOptions.prefix ?? '';
    finalHyphenInterval = byteLengthOrOptions.hyphenInterval ?? 0;
    lowercase = byteLengthOrOptions.lowercase ?? false;
  } else {
    byteLength = byteLengthOrOptions;
    finalEncoding = encoding;
    finalPrefix = prefix;
    finalHyphenInterval = hyphenInterval;
  }

  // Validate input
  if (!Number.isInteger(byteLength) || byteLength <= 0) {
    throw new Error('byteLength must be a positive integer');
  }

  if (
    finalHyphenInterval < 0 ||
    (finalHyphenInterval > 0 && !Number.isInteger(finalHyphenInterval))
  ) {
    throw new Error('hyphenInterval must be a non-negative integer');
  }

  // Generate random bytes
  const bytes = crypto.getRandomValues(new Uint8Array(byteLength));

  // Return in the requested format
  let result: string;

  switch (finalEncoding) {
    case 'hex':
      result = encodeHex(bytes);
      break;

    case 'base64':
      result = encodeBase64(bytes);
      break;

    case 'alphanumeric':
      // Convert to alphanumeric characters (0-9, a-z, A-Z)
      result = Array.from(bytes)
        .map((byte) => {
          // Map each byte to alphanumeric range
          const mod = byte % 62;
          if (mod < 10) return String.fromCharCode(48 + mod); // 0-9
          if (mod < 36) return String.fromCharCode(65 + mod - 10); // A-Z
          return String.fromCharCode(97 + mod - 36); // a-z
        })
        .join('');
      // Trim to the length that would be generated by the number of bytes
      // For alphanumeric, 1 byte = ~1.5 chars on average, so to be safe we ensure
      // we generate enough bytes and then trim
      result = result.slice(0, byteLength * 2);
      break;

    case 'raw':
      // For raw format, we ignore the prefix and hyphen formatting
      if (finalPrefix || finalHyphenInterval) {
        console.warn(
          'Prefix and hyphenInterval are ignored when using raw encoding',
        );
      }
      return bytes;

    default:
      throw new Error(
        'Invalid encoding. Must be "hex", "base64", "alphanumeric", or "raw"',
      );
  }

  // Apply lowercase if requested
  if (lowercase) {
    result = result.toLowerCase();
  }

  // Add hyphens if needed
  if (finalHyphenInterval > 0) {
    const regex = new RegExp(`.{1,${finalHyphenInterval}}`, 'g');
    result = result.match(regex)!.join('-');
  }

  // Add prefix
  return `${finalPrefix}${result}`;
};
