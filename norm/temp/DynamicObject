export type Primitive =
| string
| number
| symbol
| boolean
| null
| undefined
| void
| bigint;

export type Typeof = {
string: string;
number: number;
object: object; // eslint-disable-line @typescript-eslint/ban-types
boolean: boolean;
symbol: symbol;
bigint: bigint;
undefined: undefined;
};


const enum DBTYpe {
"string" = "string", 
"number" = "number"
}

const retType = {
string: type('string'), 
number: type('number')
}


export type FunctionParameters = unknown[];

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type FunctionType<R = any, P extends FunctionParameters = any[]> = (
...args: P
) => R;

export function type<
T extends keyof Typeof,
P extends FunctionParameters = [Typeof[T]],
>(type: T, optional=false): FunctionType<Typeof[T], P> {
return (...args: P): Typeof[T] => {
  if (typeof args[0] !== type || args[0] === null) {
    // throw toError(error || `Expect value to be "${type}"`, ...args);
    throw Error('invalid type')
  }

  return args[0] as Typeof[T];
};
}

// function getDBType<T extends keyof Typeof>(type: T): Typeof[T] {
//   return (...args: unknown): Typeof[T] => {
//     if (typeof args[0] !== type || args[0] === null) {
//       // throw toError(error || `Expect value to be "${type}"`, ...args);
//       throw Error('invalid type')
//     }
//     return args[0] as Typeof[T]
//   }
// }
// const a: ReturnType<typeof retType.number>
console.log(retType.string)

type columnDef = {
[key: string]: FunctionType
}

const a = {
abc: type('string', true), 
xyz: type('number')
};
// console.log(a.xyz(324));

type GetType<T extends columnDef> = {
[Property in keyof T]: ReturnType<T[Property]>
}

type at = GetType<typeof a>;

// export type InferType<T extends ISchema<any, any>> = T['__outputType'];
